# Типы файлов ROS

В ROS существует множество файлов. В данном разделе мы опишем некоторые из них, объясним как их создавать и как ими пользоваться.

## Launch файл

Важной частью ROS являются ноды, но запускать каждую из них отедльно неудобно. Для этого существует файлы формата `launch`. Они основаны на расширяемом языке разметки XML. 

Для начала давайте создадим простой файл запуска. Перейдите в ранее созданный проект для `Publisher и Subscriber` командой `roscd` и создайте файл запуска:

```bash
touch nodes/test.launch
```

### Основа файла запуска

Откройте новый файл и вставьте следующий код

```xml
<launch>
  <node pkg="<название пакета>" type="Publisher.py" name="<название ноды>"/>
  <node pkg="<название пакета>" type="Subscriber.py" name="<название ноды>"/>
</launch>
```

В теге `launch` содержатся остальные теги для файла запуска. Он имеет только атрибут `deprecated`, который принимает текстовое значение и выводит его, уведомляя о уствревании файла

Тег `node` отвечает за ноды и имеет следующие атрибуты

|Параметр|Описание|Значение|
|-------------------|--------------|-------------------|
|pkg|Пакет ноды|текст|
|type|Тип ноды|текст|
|name|Название ноды|текст|
|args|Аргументы, которые получит нода при запуске|значения через пробел|
|machine|Название машины, на которой будет запущена нода (ROS может быть запущен на нескольких компьютерах, объединенных единой сетью)|текст|
|respawn|Автоматически перезапускает ноду, если она закрылась|true/false|
|respawn_delay|Задержка перезапуска|секунды|
|required|При смерти ноды будет убит и весь файл запуска|true/false|
|ns|Запуск ноды в пространстве имён|текст|
|clear_params|Удаление всех параметров в частном пространстве имен узла перед запуском|true/false|
|output|Screen - отчтёт будет публиковаться в терминале, log - отчёт будет записан в логах|log/screen|
|launch-prefix|Префиксы, с которыми будет запущена нода|аргументы префиксов|
|if|True - узел будет запущен, false - узел не будет запущен (можно создавать сложные файлы запуска, где ноды будут запускаться при выполнении определённых условий)|true/false|


Для запуска нужно ввести в терминале следующую команду:

```bash
roslaunch <название пакета> test.launch
```
> **note:** Если добавить ` --screen` в конце, в терминале будет публиковаться отчёт

### Пространства имён

Вы можете объединять ноды в группы так, что они не будут пересекаться даже при одинаковых названиях и топиках. Замените предыдущий код на этот:

```xml
<launch>
  <group ns="ns1">
    <node pkg="<название пакета>" type="Publisher.py" name="<topic_publisher>"/>
    <node pkg="<название пакета>" type="Subscriber.py" name="<topic_subscriber>"/>
  </group>
  <group ns="ns2">
    <node pkg="<название пакета>" type="Publisher.py" name="<topic_publisher>"/>
    <node pkg="<название пакета>" type="Subscriber.py" name="<topic_subscriber>"/>
  </group>
</launch>
```
В данном примере 2 одинаковые пары нод содержатся в разных пространствах имён (`ns1` и `ns2`)

|Параметр|Описание|Значение|
|-------------------|--------------|-------------------|
|ns|Запуск ноды в пространстве имён|текст|
|clear_params|Удаление всех параметров в частном пространстве имен группы перед запуском.|true/false|

> **note:** Использование атрибута `clear_params` может привести к серьёзным проблемам

Запусите обновлённый файл запуска, откройте новое окно терминала и введите следующую команду: 

```bash
rostopic list
```

Она выведет работающие топики. Вы можете увидеть, что пары изолированы в своих пространствах имен.

### Переменные

Также вы можете добавлять переменные в файлы запуска.  Замените предыдущий код на этот:

<launch>
    <node pkg="test_package" type="test_params.py" name="test_params" output="log" respawn="true">
        <param name="time" value="13:30"/>
        <param name="state" value="ok"/>
    </node>
</launch>

Здесь добавился тег `param`. Он имеет следующие атрибуты:

|Параметр|Описание|Значение|
|-------------------|--------------|-------------------|
|name|Название параметра (в него могут быть включены пространства имён)|пространство_имён/название|
|value|Определяет значение параметра|текст|
|type|Тип параметра (может быть определён автоматически)|str/int/double/bool/yaml|
|textfile|Значение параметра может быть считано из текстового файла|$(find <название пакета>)/<путь>/<файл>.txt|
|binfile|Значение параметра может быть считано и записано как двоичный файл XML-RPC в кодировке base64|$(find <название пакета>)/<путь>/<файл>|
|command|Выходные данные команды будут записаны в значение параметра|$(find <название пакета>)/.exe  '$(find <название пакета>)/arg.txt'|

Следующая программа может получить информацию от параметров

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import rospy

rospy.init_node('test_params')
one = rospy.get_param('~time','00:00')
two = rospy.get_param('~state','error')

while not rospy.is_shutdown():
    print(one)
    print(two)
```

Первое значение функции `get_param` указыввает параметр, значение которого нужно получить, второй - значение по умолчаниию (оно будет передано, если значение у параметра отсутствует).

Также Вы можете объявлять параметры вне тега `node` следующим способом:

```xml
<launch>
    <arg name="resolution" default="FullHD"/>
    <arg name="state" default="good"/>

    <node pkg="<название пакета>" type="test_params.py" name="test_package" output="log" respawn="true">
        <param name="resolution" value="$(arg resolution)"/>
        <param name="state" value="$(arg state)"/>
    </node>
</launch>
```

В данном примере теги `param` получают значения от тегов `arg`. Подобный способ очень удобен, когда необходимо управялть сложным файлом запуска с большим количеством параметров. Реальный пример таких файлов Вы можете найти в `catkin_ws/src/zed-ros-wrapper/ros_wrapper/launch/`

`arg` имеет следующие атрибуты:

|Параметр|Описание|Значение|
|-------------------|--------------|-------------------|
|name|Название параметра|название|
|default|Определяет значение по умолчанию|значение|
|value|Определяет значение параметра|значение|
|doc|Описание параметра (может быть получено при добавлении аргумента `--ros-args` к `roslaunch`)|описание|

### Подключение других .launch файлов

Для боллее удобной работы с Вашими или сторонними пакетами вы можете подключать одни файлы запуска к другим.

```xml
<launch>
  <include file="$(find zed_wrapper)/launch/zed2.launch">
    
  <node pkg="<название пакета>" type="Publisher.py" name="<название ноды>"/>
  <node pkg="<название пакета>" type="Subscriber.py" name="<название ноды>"/>
</launch>
```

В данном примере тег `include` подключает файл запуска `zed2.launch` из пакета `zed_wrapper`. Теперь, запустив основной файл запуска, Вы будете включать и .launch файл для Вашей камеры. Подробнее о `zed_wrapper` Вы узнаете [здесь](https://github.com/mook003/Triados/blob/main/docs/zed.md#ros)

Тег `include` может содержать следующие атрибуты:

|Параметр|Описание|Значение|
|-------------------|--------------|-------------------|
|file|Название файла и путь к нему|$(find <название пакета>)/<путь>/<название файла>.launch|
|ns|Импортирование файла относительно пространства имен|название|
|clear_params|Удаление всех параметров в частном пространстве имен файла перед запуском|true/false|
|pass_all_args|Если значение true, то все аргументы, заданные в текущем контексте, добавляются в дочерний контекст, который создается для обработки включенного файла|true/false|

### Работа с машинами

Вам может потребоваться работать с несколькими машинами, объединенными локальной или даже глобальной сетью. Тег `machine` отвечает именно за это.

```xml
<launch>
  <machine name="foo" address="foo-address" env-loader="/opt/ros/fuerte/env.sh" user="someone"/>

  <node machine="foo" pkg="<название пакета>" type="Publisher.py"  name="footalker" />

</launch>
```

В данном примере мы создаём машину с названием `foo`, расположенную по адресу `foo-address`, именем пользователя SSH. Затем указываем в ноде атрибут `machine` со значением `foo`.

> **note:** `foo` - одна из множества [метапеременных](https://ru.wikipedia.org/wiki/Метапеременная), которые используются для обозначения чего-либо, что может стоять на их месте. Вместо неё вы должны указать необходимое вам название, путь или иное значение.

Тег `machine` может содержать следующие атрибуты:

|Параметр|Описание|Значение|
|-------------------|--------------|-------------------|
|name|Имя машины|текст|
|address|Сетевой адрес/имя хоста компьютера|соответствующие значение|
|env-loader|Файл среды на удаленном компьютере. Файл окружения должен быть сценарием оболочки, который устанавливает все необходимые переменные окружения, а затем запускает exec с предоставленными аргументами. Пример: /opt/ros/melodic/env.sh|путь|
|default|Устанавливает этот компьютер по умолчанию для назначения узлов. Параметр по умолчанию применяется только к нодам, определенным позже в той же области. ПРИМЕЧАНИЕ: если компьютеров по умолчанию нет, используется локальный компьютер. Вы можете запретить выбор машины, установив значение `never`, и в этом случае машина может быть назначена только явно|true/false/never|
|user|Имя пользователя SSH для входа в систему. Может быть опущен, если это не требуется|текст|
|password|Пароль SSH. Настоятельно рекомендуется вместо этого настроить SSH-ключи и SSH-агент, чтобы вы могли входить в систему с помощью сертификатов||
|timeout|Задержка переподключения (значение по умолчанию: 10 сек) |число|

### Обман нод

Если Вам потребуется заставить ноду подписываться на другой топик, не изменяя код ноды, можно воспользоваться `remap`:

```xml
<node pkg="<название пакета>" type="Publisher.py"  name="footalker" >
<remap from="chatter" to="hello"/>
```

В данном фрагменте тег `remap` подписывает ноду на топик `hello`, когда сама нода думает, что она подписывается на `chatter`.

Тег `remap` может содержать только атрибуты, продемонстрированные выше.

## URDF файл

Universal Robot Description Format (URDF) - Универсальный формат описания робота, основанный на XML и необходимый множеству программ для визуализации и симуляции. Существует не менее 3 способов создания этого файла: простой, сложный и дорогой.

### Fusion360 и [fusion2urdf](https://github.com/syuntoku14/fusion2urdf)

Данный способ является самым простым, но подойдёт он лишь тем, у кого есть приложение Fusion360. Скачайте репозиторий на Ваш основной компьютер, распакуйте его,  откройте терминал и введите следующую команду:

Windows
```PowerShell
cd <путь к файлу fusion2urdf>
Copy-Item ".\URDF_Exporter\" -Destination "${env:APPDATA}\Autodesk\Autodesk Fusion 360\API\Scripts\" -Recurse
```

macOS 
```bash
cd <путь к файлу fusion2urdf>
cp -r ./URDF_Exporter "$HOME/Library/Application Support/Autodesk/Autodesk Fusion 360/API/Scripts/"
```

Скачайте [этот]() файл и откройте во fusion360. Перейдите в `utilities` > `ADD-INS` > `Scripts` and `Add-Ind`. В открывшемся меню нажмите на URDF_Exporter и выберите папку для созданного файла.



<p align="right">Дальше | <b><a href="zed.md">Работа с ZED</a></b>
<br/>
Назад | <b><a href="ros.md">Введение в ROS</a></b></p>
<p align="center"><sup>2021-2022 TRIADOS | </sup><a href="../README.md#содержание"><sup>Содержание</sup></a></p>
